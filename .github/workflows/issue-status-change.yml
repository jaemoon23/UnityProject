name: Issue Status Change

on:
  issues:
    types: [closed, labeled, unlabeled, milestoned, demilestoned]

permissions:
  issues: write
  pull-requests: read

jobs:
  handle-status-change:
    runs-on: ubuntu-latest
    steps:
      - name: Handle Issue Status Change
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const https = require('https');
            
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title;
            const issueUrl = context.payload.issue.html_url;
            const action = context.payload.action;
            const labels = context.payload.issue.labels.map(l => l.name);
            const assignees = context.payload.issue.assignees;
            const milestone = context.payload.issue.milestone?.title || 'ì—†ìŒ';
            const state = context.payload.issue.state;
            
            // LMJ : GitHub username to Slack User ID mapping
            const userMapping = {
              'leemjmorris': 'U09R6F3CBHN',
              'jaemoon23': 'U09QR380TLH',
              'LeeChaeBin002': 'U09QFND0J20',
              'Kdwio': 'U09LZ9Q6F3J',
              'bigwaterplz': 'U09PKGUMVA6',
              'kimjiw8698-crypto': 'U09QDRGNT08'
            };
            
            // LMJ : Convert assignees to Slack mentions
            const slackMentions = assignees.map(a => {
              const userId = userMapping[a.login];
              return userId ? `<@${userId}>` : `@${a.login}`;
            }).join(' ') || 'ë¯¸ë°°ì •';
            
            async function sendToSlack(message) {
              const webhookUrl = process.env.SLACK_WEBHOOK_URL;
              const url = new URL(webhookUrl);
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({ text: message });
                const req = https.request({
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => resolve(body));
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function updateNotionStatus(issueUrl, status) {
              const token = process.env.NOTION_API_TOKEN;
              const databaseId = process.env.NOTION_DATABASE_ID;
              
              // LMJ : Search for page with matching URL
              return new Promise((resolve, reject) => {
                const searchData = JSON.stringify({
                  filter: {
                    property: "GitHub URL",
                    url: { equals: issueUrl }
                  }
                });
                
                const searchReq = https.request({
                  hostname: 'api.notion.com',
                  path: `/v1/databases/${databaseId}/query`,
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const searchResult = JSON.parse(body);
                      if (searchResult.results && searchResult.results.length > 0) {
                        const pageId = searchResult.results[0].id;
                        
                        // LMJ : Update status
                        const updateData = JSON.stringify({
                          properties: {
                            "ìƒíƒœ": {
                              select: { name: status }
                            }
                          }
                        });
                        
                        const updateReq = https.request({
                          hostname: 'api.notion.com',
                          path: `/v1/pages/${pageId}`,
                          method: 'PATCH',
                          headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json',
                            'Notion-Version': '2022-06-28'
                          }
                        }, (updateRes) => {
                          let updateBody = '';
                          updateRes.on('data', d => updateBody += d);
                          updateRes.on('end', () => resolve(JSON.parse(updateBody)));
                        });
                        updateReq.on('error', reject);
                        updateReq.write(updateData);
                        updateReq.end();
                      } else {
                        resolve({ error: 'Page not found' });
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                searchReq.on('error', reject);
                searchReq.write(searchData);
                searchReq.end();
              });
            }
            
            try {
              console.log(`Action: ${action}`);
              
              // ========================================
              // LMJ : Handle CLOSED event
              // ========================================
              if (action === 'closed') {
                console.log('âœ… Issue closed');
                
                // LMJ : Check if closed by PR
                let prInfo = '';
                try {
                  // LMJ : Get timeline events to find closing PR
                  const timeline = await github.rest.issues.listEventsForTimeline({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    per_page: 100
                  });
                  
                  // LMJ : Find the most recent 'closed' event with source
                  const closedEvent = timeline.data
                    .filter(e => e.event === 'closed' && e.source)
                    .pop();
                  
                  if (closedEvent && closedEvent.source && closedEvent.source.type === 'pull_request') {
                    const prNumber = closedEvent.source.issue.number;
                    const prUrl = closedEvent.source.issue.html_url;
                    const prTitle = closedEvent.source.issue.title;
                    prInfo = `\n\nğŸ”€ **PR #${prNumber}ë¡œ ì™„ë£Œë¨**\n${prTitle}\n<${prUrl}|PR ë³´ê¸°>`;
                    console.log(`Closed by PR #${prNumber}`);
                  }
                } catch (error) {
                  console.log('Could not fetch PR info:', error.message);
                }
                
                // LMJ : Send Slack notification
                const slackMessage = `âœ… *Issue #${issueNumber} ì™„ë£Œë¨*

*${issueTitle}*${prInfo}

ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}
ğŸ·ï¸ *ë ˆì´ë¸”:* ${labels.join(', ') || 'ì—†ìŒ'}
ğŸ“… *ë§ˆì¼ìŠ¤í†¤:* ${milestone}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Update Notion status
                await updateNotionStatus(issueUrl, 'ì™„ë£Œ');
                console.log('âœ… Notion status updated to ì™„ë£Œ');
              }
              
              // ========================================
              // LMJ : Handle MILESTONED event
              // ========================================
              else if (action === 'milestoned') {
                console.log('ğŸ“… Milestone assigned');
                
                // LMJ : Remove backlog label if exists
                if (labels.includes('backlog')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: 'backlog'
                    });
                    console.log('âœ… Removed backlog label');
                  } catch (error) {
                    console.log('Backlog label not found or already removed');
                  }
                }
                
                // LMJ : Add ready label
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['ready']
                });
                console.log('âœ… Added ready label');
                
                // LMJ : Send Slack notification
                const slackMessage = `ğŸ“… *Issue #${issueNumber} ë§ˆì¼ìŠ¤í†¤ í• ë‹¹*

*${issueTitle}*

ğŸ“… *ë§ˆì¼ìŠ¤í†¤:* ${milestone}
ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
              }
              
              // ========================================
              // LMJ : Handle DEMILESTONED event
              // ========================================
              else if (action === 'demilestoned') {
                console.log('ğŸ“… Milestone removed');
                
                // LMJ : Remove ready label if exists
                if (labels.includes('ready')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: 'ready'
                    });
                    console.log('âœ… Removed ready label');
                  } catch (error) {
                    console.log('Ready label not found or already removed');
                  }
                }
                
                // LMJ : Add backlog label
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['backlog']
                });
                console.log('âœ… Added backlog label');
                
                console.log('Moved issue back to backlog');
              }
              
              // ========================================
              // LMJ : Handle LABELED event
              // ========================================
              else if (action === 'labeled') {
                const addedLabel = context.payload.label.name;
                console.log(`ğŸ·ï¸ Label added: ${addedLabel}`);
                
                // LMJ : Send Slack notification for important labels
                if (['bug', 'critical', 'urgent', 'hotfix'].includes(addedLabel)) {
                  const emojiMap = {
                    'bug': 'ğŸ›',
                    'critical': 'ğŸ”´',
                    'urgent': 'âš ï¸',
                    'hotfix': 'ğŸš¨'
                  };
                  
                  const slackMessage = `${emojiMap[addedLabel] || 'ğŸ·ï¸'} *Issue #${issueNumber} ì¤‘ìš” ë¼ë²¨ ì¶”ê°€*

*${issueTitle}*

ğŸ·ï¸ *ë¼ë²¨:* ${addedLabel}
ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                  
                  await sendToSlack(slackMessage);
                  console.log('âœ… Slack notification sent for important label');
                }
              }
              
              console.log('âœ… Workflow completed successfully');
              
            } catch (error) {
              console.error('âŒ Error:', error);
              core.setFailed(error.message);
            }
