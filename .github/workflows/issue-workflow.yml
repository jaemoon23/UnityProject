name: Issue Workflow

on:
  issues:
    types: [opened, assigned, reopened]

permissions:
  contents: write
  issues: write

jobs:
  handle-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Handle Issue Event
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const https = require('https');
            const { execSync } = require('child_process');
            
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title;
            const issueBody = context.payload.issue.body || 'ë‚´ìš© ì—†ìŒ';
            const issueUrl = context.payload.issue.html_url;
            const action = context.payload.action;
            const labels = context.payload.issue.labels.map(l => l.name);
            const assignees = context.payload.issue.assignees;
            const assignee = assignees.length > 0 ? assignees[0].login : null;
            const milestone = context.payload.issue.milestone?.title || 'ì—†ìŒ';
            
            // LMJ : GitHub username to Slack User ID mapping
            const userMapping = {
              'leemjmorris': 'U09R6F3CBHN',
              'jaemoon23': 'U09QR380TLH',
              'LeeChaeBin002': 'U09QFND0J20',
              'Kdwio': 'U09LZ9Q6F3J',
              'bigwaterplz': 'U09PKGUMVA6',
              'kimjiw8698-crypto': 'U09QDRGNT08'
            };
            
            // LMJ : Convert assignees to Slack mentions
            const slackMentions = assignees.map(a => {
              const userId = userMapping[a.login];
              return userId ? `<@${userId}>` : `@${a.login}`;
            }).join(' ') || 'ë¯¸ë°°ì •';
            
            // LMJ : Label to Branch type mapping
            const labelToBranchType = {
              'bug': 'bugfix',
              'fix': 'fix',
              'hotfix': 'hotfix',
              'enhancement': 'feature',
              'feature': 'feature',
              'refactor': 'refactor',
              'documentation': 'docs',
              'docs': 'docs',
              'csvs': 'csvs'
            };
            
            // LMJ : Label to Notion tag mapping
            const labelToNotionTag = {
              'bug': 'bug',
              'enhancement': 'enhancement',
              'feature': 'enhancement',
              'documentation': 'documentation',
              'docs': 'documentation',
              'help wanted': 'help wanted',
              'wontfix': 'wontfix'
            };
            
            async function callGemini(prompt) {
              const apiKey = process.env.GEMINI_API_KEY;
              const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  contents: [{ parts: [{ text: prompt }] }],
                  generationConfig: { temperature: 0.3, maxOutputTokens: 300 }
                });
                
                const req = https.request(url, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const response = JSON.parse(body);
                      resolve(response.candidates[0].content.parts[0].text);
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function sendToSlack(message) {
              const webhookUrl = process.env.SLACK_WEBHOOK_URL;
              const url = new URL(webhookUrl);
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({ text: message });
                const req = https.request({
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => resolve(body));
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function addToNotion(title, issueUrl, tags, status) {
              const token = process.env.NOTION_API_TOKEN;
              const databaseId = process.env.NOTION_DATABASE_ID;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  parent: { database_id: databaseId },
                  properties: {
                    "ì œëª©": {
                      title: [{ text: { content: title } }]
                    },
                    "íƒ€ì…": {
                      select: { name: "Issue" }
                    },
                    "ìƒíƒœ": {
                      select: { name: status }
                    },
                    "íƒœê·¸": {
                      multi_select: tags.map(tag => ({ name: tag }))
                    },
                    "GitHub URL": {
                      url: issueUrl
                    }
                  }
                });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => resolve(JSON.parse(body)));
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function updateNotionStatus(issueUrl, status) {
              const token = process.env.NOTION_API_TOKEN;
              const databaseId = process.env.NOTION_DATABASE_ID;
              
              // LMJ : Search for page with matching URL
              return new Promise((resolve, reject) => {
                const searchData = JSON.stringify({
                  filter: {
                    property: "GitHub URL",
                    url: { equals: issueUrl }
                  }
                });
                
                const searchReq = https.request({
                  hostname: 'api.notion.com',
                  path: `/v1/databases/${databaseId}/query`,
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const searchResult = JSON.parse(body);
                      if (searchResult.results && searchResult.results.length > 0) {
                        const pageId = searchResult.results[0].id;
                        
                        // LMJ : Update status
                        const updateData = JSON.stringify({
                          properties: {
                            "ìƒíƒœ": {
                              select: { name: status }
                            }
                          }
                        });
                        
                        const updateReq = https.request({
                          hostname: 'api.notion.com',
                          path: `/v1/pages/${pageId}`,
                          method: 'PATCH',
                          headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json',
                            'Notion-Version': '2022-06-28'
                          }
                        }, (updateRes) => {
                          let updateBody = '';
                          updateRes.on('data', d => updateBody += d);
                          updateRes.on('end', () => resolve(JSON.parse(updateBody)));
                        });
                        updateReq.on('error', reject);
                        updateReq.write(updateData);
                        updateReq.end();
                      } else {
                        resolve({ error: 'Page not found' });
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                searchReq.on('error', reject);
                searchReq.write(searchData);
                searchReq.end();
              });
            }
            
            try {
              console.log(`Action: ${action}`);
              
              // ========================================
              // LMJ : Handle OPENED event
              // ========================================
              if (action === 'opened') {
                console.log('ğŸ†• Issue opened - Starting workflow...');
                
                // LMJ : Generate summary with Gemini
                const prompt = `Summarize this GitHub issue in Korean with 2-3 bullet points.

Title: ${issueTitle}
Description: ${issueBody}

RULES:
- Output ONLY bullet points (use "- " prefix)
- Each point: maximum 40 Korean characters
- Focus on KEY ACTIONS
- NO markdown, NO headers, NO extra text

Format:
- First key point
- Second key point
- Third key point (if needed)`;

                let summary;
                try {
                  summary = await callGemini(prompt);
                  summary = summary.replace(/\*\*/g, '').replace(/###/g, '').trim();
                  
                  if (!summary.includes('- ')) {
                    const lines = summary.split('\n').filter(l => l.trim());
                    summary = lines.map(l => '- ' + l.trim().replace(/^[-â€¢]\s*/, '')).join('\n');
                  }
                  
                  console.log('âœ… Summary generated');
                } catch (error) {
                  console.error('âŒ Gemini API error:', error);
                  summary = `- ${issueTitle}`;
                }
                
                // LMJ : Send Slack notification
                const slackMessage = `ğŸ†• *Issue #${issueNumber} ìƒì„±ë¨*

*${issueTitle}*

${summary}

ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}
ğŸ·ï¸ *ë ˆì´ë¸”:* ${labels.join(', ') || 'ì—†ìŒ'}
ğŸ“… *ë§ˆì¼ìŠ¤í†¤:* ${milestone}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Add to Notion
                const notionTags = labels
                  .map(label => labelToNotionTag[label])
                  .filter(Boolean);
                
                await addToNotion(issueTitle, issueUrl, notionTags, 'ëŒ€ê¸°');
                console.log('âœ… Added to Notion');
                
                // LMJ : Add backlog label if no labels
                if (labels.length === 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['backlog']
                  });
                  console.log('âœ… Added backlog label');
                }
                
                // LMJ : Check if assignee exists and create branch
                if (assignee) {
                  console.log('ğŸ‘¤ Assignee detected, creating branch...');
                  
                  // LMJ : Check for non-branch labels
                  if (labels.includes('feature-request') || labels.includes('meeting')) {
                    console.log('â„¹ï¸ Issue type does not create branches');
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: 'â„¹ï¸ **ì´ IssueëŠ” ë¸Œëœì¹˜ë¥¼ ìë™ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**'
                    });
                  } else {
                    // LMJ : Determine branch type
                    let branchType = 'feature';
                    for (const [label, type] of Object.entries(labelToBranchType)) {
                      if (labels.includes(label)) {
                        branchType = type;
                        break;
                      }
                    }
                    
                    // LMJ : Create branch name
                    const cleanTitle = issueTitle.replace(/^\[.*?\]\s*/, '');
                    const description = cleanTitle
                      .toLowerCase()
                      .replace(/[^a-z0-9\s-]/g, '')
                      .trim()
                      .replace(/\s+/g, '-')
                      .replace(/-+/g, '-')
                      .replace(/^-|-$/g, '');
                    
                    const branchName = `${branchType}/${issueNumber}-${description}`;
                    
                    console.log(`Creating branch: ${branchName}`);
                    
                    // LMJ : Configure git
                    execSync('git config user.name "github-actions[bot]"');
                    execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
                    
                    // LMJ : Check if branch exists
                    try {
                      execSync(`git ls-remote --heads origin "${branchName}"`);
                      console.log('âš ï¸ Branch already exists');
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        body: `âš ï¸ **Branchê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤:** \`${branchName}\``
                      });
                    } catch {
                      // LMJ : Branch doesn't exist, create it
                      execSync('git checkout main');
                      execSync('git pull origin main');
                      execSync(`git checkout -b "${branchName}"`);
                      execSync(`git push origin "${branchName}"`);
                      
                      console.log('âœ… Branch created');
                      
                      // LMJ : Add comment with instructions
                      const comment = `âœ… **Branchê°€ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!**

\`\`\`
${branchName}
\`\`\`

ğŸ“‹ **ë‹¤ìŒ ë‹¨ê³„:**
1. ë¡œì»¬ì—ì„œ ë¸Œëœì¹˜ë¥¼ ì²´í¬ì•„ì›ƒí•˜ì„¸ìš”:
\`\`\`bash
git fetch origin
git checkout ${branchName}
\`\`\`

2. ì‘ì—…ì„ ì™„ë£Œí•˜ê³  ì»¤ë°‹í•˜ì„¸ìš”

3. PR ìƒì„± ì‹œ ì´ Issueë¥¼ ìë™ìœ¼ë¡œ ë‹«ìœ¼ë ¤ë©´ PR ì„¤ëª…ì— ë‹¤ìŒì„ í¬í•¨í•˜ì„¸ìš”:
\`Closes #${issueNumber}\`

ğŸ¯ **ë‹´ë‹¹ì:** ${slackMentions}

ğŸ’¡ **Tip:** ë¸Œëœì¹˜ëª…ì— Issue ë²ˆí˜¸(#${issueNumber})ê°€ í¬í•¨ë˜ì–´ ìˆì–´ ì¶”ì ì´ ìš©ì´í•©ë‹ˆë‹¤!`;
                      
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        body: comment
                      });
                      
                      // LMJ : Update Notion status
                      await updateNotionStatus(issueUrl, 'ì§„í–‰ì¤‘');
                      console.log('âœ… Notion status updated to ì§„í–‰ì¤‘');
                    }
                  }
                }
              }
              
              // ========================================
              // LMJ : Handle ASSIGNED event
              // ========================================
              else if (action === 'assigned') {
                console.log('ğŸ‘¤ Assignee assigned - Creating branch...');
                
                // LMJ : Check for non-branch labels
                if (labels.includes('feature-request') || labels.includes('meeting')) {
                  console.log('â„¹ï¸ Issue type does not create branches');
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: 'â„¹ï¸ **ì´ IssueëŠ” ë¸Œëœì¹˜ë¥¼ ìë™ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**'
                  });
                } else {
                  // LMJ : Determine branch type
                  let branchType = 'feature';
                  for (const [label, type] of Object.entries(labelToBranchType)) {
                    if (labels.includes(label)) {
                      branchType = type;
                      break;
                    }
                  }
                  
                  // LMJ : Create branch name
                  const cleanTitle = issueTitle.replace(/^\[.*?\]\s*/, '');
                  const description = cleanTitle
                    .toLowerCase()
                    .replace(/[^a-z0-9\s-]/g, '')
                    .trim()
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-|-$/g, '');
                  
                  const branchName = `${branchType}/${issueNumber}-${description}`;
                  
                  console.log(`Creating branch: ${branchName}`);
                  
                  // LMJ : Configure git
                  execSync('git config user.name "github-actions[bot]"');
                  execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
                  
                  // LMJ : Check if branch exists
                  try {
                    execSync(`git ls-remote --heads origin "${branchName}"`);
                    console.log('âš ï¸ Branch already exists');
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: `âš ï¸ **Branchê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤:** \`${branchName}\``
                    });
                  } catch {
                    // LMJ : Branch doesn't exist, create it
                    execSync('git checkout main');
                    execSync('git pull origin main');
                    execSync(`git checkout -b "${branchName}"`);
                    execSync(`git push origin "${branchName}"`);
                    
                    console.log('âœ… Branch created');
                    
                    // LMJ : Send Slack notification
                    const slackMessage = `ğŸ‘¤ *Issue #${issueNumber} ë‹´ë‹¹ì ë°°ì •ë¨*

*${issueTitle}*

âœ… **Branch ìƒì„± ì™„ë£Œ**
\`${branchName}\`

ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                    
                    await sendToSlack(slackMessage);
                    
                    // LMJ : Add comment with instructions
                    const comment = `âœ… **Branchê°€ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!**

\`\`\`
${branchName}
\`\`\`

ğŸ“‹ **ë‹¤ìŒ ë‹¨ê³„:**
1. ë¡œì»¬ì—ì„œ ë¸Œëœì¹˜ë¥¼ ì²´í¬ì•„ì›ƒí•˜ì„¸ìš”:
\`\`\`bash
git fetch origin
git checkout ${branchName}
\`\`\`

2. ì‘ì—…ì„ ì™„ë£Œí•˜ê³  ì»¤ë°‹í•˜ì„¸ìš”

3. PR ìƒì„± ì‹œ ì´ Issueë¥¼ ìë™ìœ¼ë¡œ ë‹«ìœ¼ë ¤ë©´ PR ì„¤ëª…ì— ë‹¤ìŒì„ í¬í•¨í•˜ì„¸ìš”:
\`Closes #${issueNumber}\`

ğŸ¯ **ë‹´ë‹¹ì:** ${slackMentions}

ğŸ’¡ **Tip:** ë¸Œëœì¹˜ëª…ì— Issue ë²ˆí˜¸(#${issueNumber})ê°€ í¬í•¨ë˜ì–´ ìˆì–´ ì¶”ì ì´ ìš©ì´í•©ë‹ˆë‹¤!`;
                    
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: comment
                    });
                    
                    // LMJ : Update Notion status
                    await updateNotionStatus(issueUrl, 'ì§„í–‰ì¤‘');
                    console.log('âœ… Notion status updated to ì§„í–‰ì¤‘');
                  }
                }
              }
              
              // ========================================
              // LMJ : Handle REOPENED event
              // ========================================
              else if (action === 'reopened') {
                console.log('ğŸ”„ Issue reopened');
                
                // LMJ : Send Slack notification
                const slackMessage = `ğŸ”„ *Issue #${issueNumber} ì¬ì˜¤í”ˆë¨*

*${issueTitle}*

ğŸ‘¤ *ë‹´ë‹¹:* ${slackMentions}
ğŸ·ï¸ *ë ˆì´ë¸”:* ${labels.join(', ') || 'ì—†ìŒ'}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Update Notion status
                await updateNotionStatus(issueUrl, 'ì¬ì˜¤í”ˆ');
                console.log('âœ… Notion status updated to ì¬ì˜¤í”ˆ');
              }
              
              console.log('âœ… Workflow completed successfully');
              
            } catch (error) {
              console.error('âŒ Error:', error);
              core.setFailed(error.message);
            }
