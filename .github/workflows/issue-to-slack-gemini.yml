name: Issue to Slack (Gemini-powered)

on:
  issues:
    types: [opened, closed, reopened]

jobs:
  notify-slack:
    runs-on: ubuntu-latest
    permissions:
      issues: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Process issue with Gemini and send to Slack
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
          ISSUE_LABELS: ${{ toJson(github.event.issue.labels) }}
          ISSUE_ASSIGNEES: ${{ toJson(github.event.issue.assignees) }}
          ISSUE_MILESTONE: ${{ github.event.issue.milestone.title }}
          ACTION: ${{ github.event.action }}
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');
            
            // Gemini API í˜¸ì¶œ í•¨ìˆ˜
            async function callGeminiAPI(prompt) {
              const apiKey = process.env.GEMINI_API_KEY;
              const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
              
              const data = JSON.stringify({
                contents: [{
                  parts: [{
                    text: prompt
                  }]
                }],
                generationConfig: {
                  temperature: 0.3,
                  maxOutputTokens: 300,
                  topP: 0.8,
                  topK: 40
                }
              });
              
              return new Promise((resolve, reject) => {
                const req = https.request(url, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': data.length
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', chunk => body += chunk);
                  res.on('end', () => {
                    try {
                      const response = JSON.parse(body);
                      if (response.candidates && response.candidates[0]) {
                        const text = response.candidates[0].content.parts[0].text;
                        resolve(text);
                      } else {
                        reject(new Error('Invalid Gemini API response'));
                      }
                    } catch (error) {
                      reject(error);
                    }
                  });
                });
                
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            // Slackì— ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
            async function sendToSlack(message) {
              const webhookUrl = process.env.SLACK_WEBHOOK_URL;
              const url = new URL(webhookUrl);
              
              const data = JSON.stringify({ text: message });
              
              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': data.length
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', chunk => body += chunk);
                  res.on('end', () => resolve(body));
                });
                
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            // ë©”ì¸ ë¡œì§
            try {
              const issueTitle = process.env.ISSUE_TITLE;
              const issueBody = process.env.ISSUE_BODY || 'ë‚´ìš© ì—†ìŒ';
              const issueNumber = process.env.ISSUE_NUMBER;
              const issueUrl = process.env.ISSUE_URL;
              const issueUser = process.env.ISSUE_USER;
              const action = process.env.ACTION;
              const labels = JSON.parse(process.env.ISSUE_LABELS || '[]');
              const assignees = JSON.parse(process.env.ISSUE_ASSIGNEES || '[]');
              const milestone = process.env.ISSUE_MILESTONE || 'ì—†ìŒ';
              
              // ì•¡ì…˜ì— ë”°ë¥¸ ì´ëª¨ì§€
              const actionEmoji = {
                'opened': 'ğŸ†•',
                'closed': 'âœ…',
                'reopened': 'ğŸ”„'
              };
              
              const actionText = {
                'opened': 'ìƒì„±ë¨',
                'closed': 'ì™„ë£Œë¨', 
                'reopened': 'ì¬ì˜¤í”ˆë¨'
              };
              
              // ë ˆì´ë¸” ì •ë³´
              const labelNames = labels.map(l => l.name).join(', ') || 'ì—†ìŒ';
              
              // ë‹´ë‹¹ì ì •ë³´
              const assigneeNames = assignees.map(a => a.login).join(', ') || 'ë¯¸ë°°ì •';
              
              // Geminiì—ê²Œ ìš”ì•½ ìš”ì²­ (ë§¤ìš° êµ¬ì²´ì ì´ê³  ì—„ê²©í•œ í”„ë¡¬í”„íŠ¸)
              const prompt = `You are a GitHub issue summarizer. Your task is to create a VERY SHORT Korean summary.

INPUT DATA:
- Title: ${issueTitle}
- Description: ${issueBody}
- Labels: ${labelNames}
- Assignee: ${assigneeNames}
- Milestone: ${milestone}

RULES (CRITICAL - MUST FOLLOW):
1. Output ONLY 1-2 sentences in Korean
2. Maximum 100 characters total
3. Focus on WHAT needs to be done, not technical details
4. Use simple, clear Korean
5. Do NOT include any markdown, formatting, or extra information
6. Do NOT repeat the title
7. Just write the core summary - nothing else

Example good output:
"Data Manager ì‹±ê¸€í†¤ìœ¼ë¡œ CSV íŒŒì‹± êµ¬í˜„. ìŠ¤í…Œì´ì§€, ìºë¦­í„°, ëª¬ìŠ¤í„°, ìŠ¤í‚¬, íš¨ê³¼ ë°ì´í„° ìš°ì„  ì²˜ë¦¬."

NOW WRITE THE SUMMARY:`;

              console.log('Gemini API í˜¸ì¶œ ì¤‘...');
              let summary;
              try {
                summary = await callGeminiAPI(prompt);
                // ë¶ˆí•„ìš”í•œ ë§ˆí¬ë‹¤ìš´ ì œê±°
                summary = summary.replace(/\*\*/g, '').replace(/###/g, '').replace(/\n\n+/g, '\n').trim();
                console.log('Gemini ìš”ì•½ ì™„ë£Œ:', summary);
              } catch (error) {
                console.error('Gemini API ì—ëŸ¬:', error);
                // Fallback: ì œëª©ë§Œ ì‚¬ìš©
                summary = issueTitle;
              }
              
              // Slack ë©”ì‹œì§€ êµ¬ì„± (ê¹”ë”í•œ í˜•ì‹)
              const slackMessage = `${actionEmoji[action]} *Issue #${issueNumber} ${actionText[action]}*

*${issueTitle}*

${summary}

ğŸ‘¤ *ë‹´ë‹¹:* ${assigneeNames}
ğŸ·ï¸ *ë ˆì´ë¸”:* ${labelNames}
ğŸ“… *ë§ˆì¼ìŠ¤í†¤:* ${milestone}

ğŸ”— <${issueUrl}|ìì„¸íˆ ë³´ê¸°>`;
              
              console.log('Slackìœ¼ë¡œ ì „ì†¡ ì¤‘...');
              await sendToSlack(slackMessage);
              console.log('Slack ì „ì†¡ ì™„ë£Œ!');
              
            } catch (error) {
              console.error('Error:', error);
              core.setFailed(error.message);
            }
